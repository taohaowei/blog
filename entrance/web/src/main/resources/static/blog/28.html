<div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<div style="top:0px">﻿﻿</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<div class="post-meta"><span class="post-comments-count"> 
<p>在java的内存分配中，经常听到很多关于常量池的描述，网上五花八门的说法简直太多</p>
<h3 id="1-全局字符串池（string_pool也有叫做string_literal_pool）">1.全局字符串池（string pool也有叫做string literal pool）</h3>
<p>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（<strong>记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。</strong>）。<br>
在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</p>
<h3 id="2-class文件常量池（class_constant_pool）"><a name="t1" target="_blank"></a>2.class文件常量池（class constant pool）</h3>
<p>我们都知道，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的<strong>各种字面量(Literal)和符号引用(Symbolic References)</strong>。<br>
字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。<br>
符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul>
<p>常量池的每一项常量都是一个表，一共有如下表所示的14种(JDK7以后又加了3中)各不相同的表结构数据，这每个表开始的第一位都是一个字节的标志位（取值1-12），代表当前这个常量属于哪种常量类型。<a target="_blank" id="more"></a><br>
<img alt="常量池的项目类型1" src="http://my-night.oss-cn-beijing.aliyuncs.com/pic/String_JVM_02.jpg"/><img alt="常量池的项目类型2" src="http://my-night.oss-cn-beijing.aliyuncs.com/pic/String_JVM_03.jpg"/><br>
每种不同类型的常量类型具有不同的结构，具体的结构这里就先不叙述了，不需要记，本文着重区分这三个常量池的概念（读者若想深入了解每种常量类型的数据结构可以查看《深入理解java虚拟机-第二版》第六章的内容）。</p>
<h3 id="3-运行时常量池（runtime_constant_pool）"><a name="t2" target="_blank"></a>3.运行时常量池（runtime constant pool）</h3>
<p>当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？</p>
<p>jvm在执行某个类的时候，必须经过<strong>加载、连接、初始化</strong>，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p>






</div>
   
</div>