<div class="container"><h2 id="利用java向mysql插入一亿数量级数据效率测评">利用JAVA向Mysql插入一亿数量级数据—效率测评</h2>

<blockquote>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前景：这几天研究mysql优化中查询效率时，发现测试的数据太少（10万级别），利用 EXPLAIN 比较不同的 SQL 语句，不能够得到比较有效的测评数据，大多模棱两可，不敢通过这些数据下定论。</p>
  
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以<strong>通过随机生成人的姓名、年龄、性别、电话、email、地址 ，向mysql数据库大量插入数据，便于用大量的数据测试 SQL 语句优化效率。</strong>、在生成过程中发现使用不同的方法，效率天差万别。</p>
</blockquote>

<p><strong>提示：</strong></p>

<blockquote>
  <p>下文展示代码为部分代码，<a href="git@github.com:taohaowei/testBigData.git">git@github.com:taohaowei/testBigData.git</a> <br>
  转载请标明出处：—–by <a href="http://blog.csdn.net/q6834850">陶浩伟</a></p>
</blockquote>

<hr>



<h3 id="1-先上mysql数据库随机生成的人员数据图分别是id姓名性别年龄email电话住址下图一共三千三百万数据"><strong>1. 先上Mysql数据库，随机生成的人员数据图。分别是ID、姓名、性别、年龄、Email、电<br/>话、住址。下图一共三千三百万数据：</strong></h3>

<hr>

<p><img src="https://taohaowei.github.io/savePicture/blog/19/1.png" alt="模拟数据" title=""></p>

<p>** <br>
在数据量在亿级别时。别点下面按钮，会导致Navicat持续加载这亿级别的数据，</p>

<p>导致电脑死机。~觉着自己电脑配置不错的可以去试试，可能会有惊喜</p>

<p>**</p>

<p><img src="https://taohaowei.github.io/savePicture/blog/19/2.png" alt="禁止点击" title=""></p>

<hr>



<h3 id="2本次测评一共通过三种策略五种情况进行大批量数据插入测试"><strong>2、本次测评一共通过三种策略，五种情况，进行大批量数据插入测试</strong></h3>

<pre><code>    策略分别是：
    1、Mybatis 轻量级框架插入（无事务）
    2、采用JDBC直接处理（开启事务、无事务）
    3、采用JDBC批处理（开启事务、无事务）
</code></pre>



<h4 id="先展示测试结果耗费时间"><strong><em>先展示测试结果：</em></strong>（耗费时间）</h4>



<h4 id="mybatis轻量级插入-jdbc直接处理-jdbc-批处理">&nbsp;&nbsp;&nbsp;&nbsp;<strong><em>Mybatis轻量级插入  -》 JDBC直接处理  -》  JDBC 批处理。</em></strong></h4>



<h4 id="jdbc-批处理效率最高"><strong><em>JDBC 批处理，效率最高</em></strong></h4>

<hr>

<p>下面开始第一种策略测试：</p>

<hr>



<h4 id="21-mybatis-轻量级框架插入无事务">2.1  Mybatis 轻量级框架插入（无事务）</h4>

<pre><code>    Mybatis是一个轻量级框架，它比hibernate轻便、效率高。但是处理大批

量的数据插入操作时，需要过程中实现一个ORM的转换，本次测试存在实例，以及

未开启事务，导致mybatis效率很一般。这里实验内容是：

    1、利用Spring框架生成mapper实例、创建人物实例对象

    2、循环更改该实例对象属性、并插入。
</code></pre>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//代码内无事务</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> begin = <span class="hljs-number">33112001</span>;<span class="hljs-comment">//起始id</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> end = begin+<span class="hljs-number">100000</span>;<span class="hljs-comment">//每次循环插入的数据量</span>
    <span class="hljs-keyword">private</span> String url = <span class="hljs-string">"jdbc:mysql://localhost:3306/bigdata?useServerPrepStmts=false&amp;rewriteBatchedStatements=true&amp;useUnicode=true&amp;amp;characterEncoding=UTF-8"</span>;
    <span class="hljs-keyword">private</span> String user = <span class="hljs-string">"root"</span>;
    <span class="hljs-keyword">private</span> String password = <span class="hljs-string">"0203"</span>;


@org.junit.Test
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertBigData2</span>()
    {
        <span class="hljs-comment">//加载Spring，以及得到PersonMapper实例对象。这里创建的时间并不对最后结果产生很大的影响</span>
        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>);
        PersonMapper pMapper = (PersonMapper) context.getBean(<span class="hljs-string">"personMapper"</span>);
        <span class="hljs-comment">//创建一个人实例</span>
        Person person = <span class="hljs-keyword">new</span> Person();
        <span class="hljs-comment">//计开始时间</span>
        <span class="hljs-keyword">long</span> bTime = System.currentTimeMillis();
        <span class="hljs-comment">//开始循环，循环次数500W次。</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5000000</span>;i++)
        {
            <span class="hljs-comment">//为person赋值</span>
            person.setId(i);
            person.setName(RandomValue.getChineseName());
            person.setSex(RandomValue.name_sex);
            person.setAge(RandomValue.getNum(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>));
            person.setEmail(RandomValue.getEmail(<span class="hljs-number">4</span>,<span class="hljs-number">15</span>));
            person.setTel(RandomValue.getTel());
            person.setAddress(RandomValue.getRoad());
            <span class="hljs-comment">//执行插入语句</span>
            pMapper.insert(person);
            begin++;
        }
        <span class="hljs-comment">//计结束时间</span>
        <span class="hljs-keyword">long</span> eTime = System.currentTimeMillis();
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"插入500W条数据耗时："</span>+(eTime-bTime));
    }</code></pre>

<pre><code>    本想测试插入五百万条数据，但是实际运行过程中太慢，中途不得不终止程

序。最后得到52W数据，大约耗时两首歌的时间（7~9分钟）。随后，利用mybatis向mysql插入 一万 数据。结果如下： 
</code></pre>

<blockquote>
  <p><strong><em>利用mybatis插入 一万 条数据耗时：28613，即*28.6</em>秒*</strong></p>
</blockquote>

<p><img src="https://taohaowei.github.io/savePicture/blog/19/3.png" alt="1W数据耗时" title=""></p>

<hr>

<p>下面开始第二种策略测试：</p>

<hr>



<h3 id="22-采用jdbc直接处理开启事务关闭事务">2.2  采用JDBC直接处理（开启事务、关闭事务）</h3>

<pre><code>    采用JDBC直接处理的策略，这里的实验内容分为开启事务、未开启事务是两种，过程均如下：

    1、利用PreparedStatment预编译

    2、循环，插入对应数据，并存入
</code></pre>

<p><strong>事务对于插入数据有多大的影响呢？</strong>看下面的实验结果:</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//该代码为开启事务</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> begin = <span class="hljs-number">33112001</span>;<span class="hljs-comment">//起始id</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> end = begin+<span class="hljs-number">100000</span>;<span class="hljs-comment">//每次循环插入的数据量</span>
    <span class="hljs-keyword">private</span> String url = <span class="hljs-string">"jdbc:mysql://localhost:3306/bigdata?useServerPrepStmts=false&amp;rewriteBatchedStatements=true&amp;useUnicode=true&amp;amp;characterEncoding=UTF-8"</span>;
    <span class="hljs-keyword">private</span> String user = <span class="hljs-string">"root"</span>;
    <span class="hljs-keyword">private</span> String password = <span class="hljs-string">"0203"</span>;


@org.junit.Test
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertBigData3</span>() {
        <span class="hljs-comment">//定义连接、statement对象</span>
        Connection conn = <span class="hljs-keyword">null</span>;
        PreparedStatement pstm = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//加载jdbc驱动</span>
            Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);
            <span class="hljs-comment">//连接mysql</span>
            conn = DriverManager.getConnection(url, user, password);
             <span class="hljs-comment">//将自动提交关闭</span>
             conn.setAutoCommit(<span class="hljs-keyword">false</span>);
            <span class="hljs-comment">//编写sql</span>
            String sql = <span class="hljs-string">"INSERT INTO person VALUES (?,?,?,?,?,?,?)"</span>;
            <span class="hljs-comment">//预编译sql</span>
            pstm = conn.prepareStatement(sql);
            <span class="hljs-comment">//开始总计时</span>
            <span class="hljs-keyword">long</span> bTime1 = System.currentTimeMillis();

            <span class="hljs-comment">//循环10次，每次一万数据，一共10万</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) {
                <span class="hljs-comment">//开启分段计时，计1W数据耗时</span>
                <span class="hljs-keyword">long</span> bTime = System.currentTimeMillis();
                <span class="hljs-comment">//开始循环</span>
                <span class="hljs-keyword">while</span> (begin &lt; end) {
                    <span class="hljs-comment">//赋值</span>
                    pstm.setLong(<span class="hljs-number">1</span>, begin);
                    pstm.setString(<span class="hljs-number">2</span>, RandomValue.getChineseName());
                    pstm.setString(<span class="hljs-number">3</span>, RandomValue.name_sex);
                    pstm.setInt(<span class="hljs-number">4</span>, RandomValue.getNum(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>));
                    pstm.setString(<span class="hljs-number">5</span>, RandomValue.getEmail(<span class="hljs-number">4</span>, <span class="hljs-number">15</span>));
                    pstm.setString(<span class="hljs-number">6</span>, RandomValue.getTel());
                    pstm.setString(<span class="hljs-number">7</span>, RandomValue.getRoad());
                    <span class="hljs-comment">//执行sql</span>
                    pstm.execute();
                    begin++;
                }
                <span class="hljs-comment">//提交事务</span>
                conn.commit();
                <span class="hljs-comment">//边界值自增10W</span>
                end += <span class="hljs-number">10000</span>;
                <span class="hljs-comment">//关闭分段计时</span>
                <span class="hljs-keyword">long</span> eTime = System.currentTimeMillis();
                <span class="hljs-comment">//输出</span>
                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"成功插入1W条数据耗时："</span>+(eTime-bTime));
            }
            <span class="hljs-comment">//关闭总计时</span>
            <span class="hljs-keyword">long</span> eTime1 = System.currentTimeMillis();
            <span class="hljs-comment">//输出</span>
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"插入10W数据共耗时："</span>+(eTime1-bTime1));
        } <span class="hljs-keyword">catch</span> (SQLException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e1) {
            e1.printStackTrace();
        }
    }</code></pre>

<pre><code>1、我们首先利用上述代码测试无事务状态下，插入10W条数据需要耗时多少。如图：
</code></pre>

<p><img src="https://taohaowei.github.io/savePicture/blog/19/5.png" alt="无事务插入" title=""></p>

<blockquote>
  <p>成功插入1W条数据耗时：21603 <br>
  成功插入1W条数据耗时：20537 <br>
  成功插入1W条数据耗时：20470 <br>
  成功插入1W条数据耗时：21160 <br>
  成功插入1W条数据耗时：23270 <br>
  成功插入1W条数据耗时：21230 <br>
  成功插入1W条数据耗时：20372 <br>
  成功插入1W条数据耗时：22608 <br>
  成功插入1W条数据耗时：20361 <br>
  成功插入1W条数据耗时：20494 <br>
  插入10W数据共耗时：212106</p>
</blockquote>

<p>实验结论如下：</p>

<blockquote>
  <p><strong><em>在未开启事务的情况下，平均每 21.2 秒插入 一万 数据。</em></strong></p>
</blockquote>

<pre><code>接着我们测试开启事务后，插入十万条数据耗时，如图：
</code></pre>

<p><img src="https://taohaowei.github.io/savePicture/blog/19/5.png" alt="开始事务后" title=""></p>

<blockquote>
  <p>成功插入1W条数据耗时：4938 <br>
  成功插入1W条数据耗时：3518 <br>
  成功插入1W条数据耗时：3713 <br>
  成功插入1W条数据耗时：3883 <br>
  成功插入1W条数据耗时：3872 <br>
  成功插入1W条数据耗时：3873 <br>
  成功插入1W条数据耗时：3863 <br>
  成功插入1W条数据耗时：3819 <br>
  成功插入1W条数据耗时：3933 <br>
  成功插入1W条数据耗时：3811 <br>
  插入10W数据共耗时：39255</p>
</blockquote>

<p>实验结论如下：</p>

<blockquote>
  <p><strong><em>开启事务后，平均每 3.9 秒插入 一万 数据</em></strong></p>
</blockquote>

<hr>

<p>下面开始第三种策略测试：</p>

<hr>



<h3 id="23-采用jdbc批处理开启事务无事务">2.3  采用JDBC批处理（开启事务、无事务）</h3>

<blockquote>
  <p>采用JDBC批处理时需要注意一下几点：</p>
  
  <p><strong>1、在URL连接时需要开启批处理、以及预编译</strong> <br>
  String url =  “jdbc:mysql://localhost:3306/User?rewriteBatched <br>
  -Statements=true&amp;useServerPrepStmts=false”;</p>
  
  <p><strong>2、PreparedStatement预处理sql语句必须放在循环体外</strong></p>
</blockquote>

<hr>

<p>代码如下：</p>



<pre class="prettyprint"><code class=" hljs cs">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> begin = <span class="hljs-number">33112001</span>;<span class="hljs-comment">//起始id</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> end = begin+<span class="hljs-number">100000</span>;<span class="hljs-comment">//每次循环插入的数据量</span>
    <span class="hljs-keyword">private</span> String url = <span class="hljs-string">"jdbc:mysql://localhost:3306/bigdata?useServerPrepStmts=false&amp;rewriteBatchedStatements=true&amp;useUnicode=true&amp;amp;characterEncoding=UTF-8"</span>;
    <span class="hljs-keyword">private</span> String user = <span class="hljs-string">"root"</span>;
    <span class="hljs-keyword">private</span> String password = <span class="hljs-string">"0203"</span>;


    @org.junit.Test
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertBigData</span>() {
        <span class="hljs-comment">//定义连接、statement对象</span>
        Connection conn = <span class="hljs-keyword">null</span>;
        PreparedStatement pstm = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//加载jdbc驱动</span>
            Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);
            <span class="hljs-comment">//连接mysql</span>
            conn = DriverManager.getConnection(url, user, password);
            <span class="hljs-comment">//将自动提交关闭</span>
            <span class="hljs-comment">// conn.setAutoCommit(false);</span>
            <span class="hljs-comment">//编写sql</span>
            String sql = <span class="hljs-string">"INSERT INTO person VALUES (?,?,?,?,?,?,?)"</span>;
            <span class="hljs-comment">//预编译sql</span>
            pstm = conn.prepareStatement(sql);
            <span class="hljs-comment">//开始总计时</span>
            <span class="hljs-keyword">long</span> bTime1 = System.currentTimeMillis();

            <span class="hljs-comment">//循环10次，每次十万数据，一共1000万</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) {

                <span class="hljs-comment">//开启分段计时，计1W数据耗时</span>
                <span class="hljs-keyword">long</span> bTime = System.currentTimeMillis();
                <span class="hljs-comment">//开始循环</span>
                <span class="hljs-keyword">while</span> (begin &lt; end) {
                    <span class="hljs-comment">//赋值</span>
                    pstm.setLong(<span class="hljs-number">1</span>, begin);
                    pstm.setString(<span class="hljs-number">2</span>, RandomValue.getChineseName());
                    pstm.setString(<span class="hljs-number">3</span>, RandomValue.name_sex);
                    pstm.setInt(<span class="hljs-number">4</span>, RandomValue.getNum(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>));
                    pstm.setString(<span class="hljs-number">5</span>, RandomValue.getEmail(<span class="hljs-number">4</span>, <span class="hljs-number">15</span>));
                    pstm.setString(<span class="hljs-number">6</span>, RandomValue.getTel());
                    pstm.setString(<span class="hljs-number">7</span>, RandomValue.getRoad());
                    <span class="hljs-comment">//添加到同一个批处理中</span>
                    pstm.addBatch();
                    begin++;
                }
                <span class="hljs-comment">//执行批处理</span>
                pstm.executeBatch();
<span class="hljs-comment">//                //提交事务</span>
<span class="hljs-comment">//                conn.commit();</span>
                <span class="hljs-comment">//边界值自增10W</span>
                end += <span class="hljs-number">100000</span>;
                <span class="hljs-comment">//关闭分段计时</span>
                <span class="hljs-keyword">long</span> eTime = System.currentTimeMillis();
                <span class="hljs-comment">//输出</span>
                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"成功插入10W条数据耗时："</span>+(eTime-bTime));
            }
            <span class="hljs-comment">//关闭总计时</span>
            <span class="hljs-keyword">long</span> eTime1 = System.currentTimeMillis();
            <span class="hljs-comment">//输出</span>
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"插入100W数据共耗时："</span>+(eTime1-bTime1));
        } <span class="hljs-keyword">catch</span> (SQLException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException e1) {
            e1.printStackTrace();
        }
    }</code></pre>

<hr>

<p><strong>首先开始测试</strong> <br>
&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>无事务，每次循环插入10W条数据，循环10次，一共100W条数据。结果如下图：</strong></p>

<p><img src="https://taohaowei.github.io/savePicture/blog/19/6.png" alt="未开启事务批处理" title=""></p>

<blockquote>
  <p>成功插入10W条数据耗时：3832 <br>
  成功插入10W条数据耗时：1770 <br>
  成功插入10W条数据耗时：2628 <br>
  成功插入10W条数据耗时：2140 <br>
  成功插入10W条数据耗时：2148 <br>
  成功插入10W条数据耗时：1757 <br>
  成功插入10W条数据耗时：1767 <br>
  成功插入10W条数据耗时：1832 <br>
  成功插入10W条数据耗时：1830 <br>
  成功插入10W条数据耗时：2031 <br>
  插入100W数据共耗时：21737</p>
</blockquote>

<p>实验结果：</p>

<blockquote>
  <p><strong><em>使用JDBC批处理，未开启事务下，平均每 2.1 秒插入 十万 条数据</em></strong></p>
</blockquote>

<p><strong>接着测试</strong> <br>
&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>开启事务，每次循环插入10W条数据，循环10次，一共100W条数据。结果如下图：</strong> <br>
<img src="https://taohaowei.github.io/savePicture/blog/19/7.png" alt="这里写图片描述" title=""></p>

<blockquote>
  <p>成功插入10W条数据耗时：3482 <br>
  成功插入10W条数据耗时：1776 <br>
  成功插入10W条数据耗时：1979 <br>
  成功插入10W条数据耗时：1730 <br>
  成功插入10W条数据耗时：1643 <br>
  成功插入10W条数据耗时：1665 <br>
  成功插入10W条数据耗时：1622 <br>
  成功插入10W条数据耗时：1624 <br>
  成功插入10W条数据耗时：1779 <br>
  成功插入10W条数据耗时：1698 <br>
  插入100W数据共耗时：19003</p>
</blockquote>

<p>实验结果：</p>

<blockquote>
  <p><strong><em>使用JDBC批处理，开启事务，平均每 1.9 秒插入&nbsp;十万&nbsp;条数据</em></strong></p>
</blockquote>



<h3 id="3-总结">3  总结</h3>

<blockquote>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够看到，在开启事务下  <strong><em>JDBC直接处理</em></strong>  和  <strong><em>JDBC批处理</em></strong>  均耗时更短。</p>
  
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em>Mybatis 轻量级框架插入</em></strong> ,  mybatis在我这次实验被黑的可惨了，哈哈。实际开启事务以后，差距不会这么大（差距10倍）。大家有兴趣的可以接着去测试 <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em>JDBC直接处理</em></strong>，在本次实验，开启事务和关闭事务，耗时差距5倍左右，并且这个倍数会随着数据量的增大而增大。因为在未开启事务时，更新10000条数据，就得访问数据库10000次。导致每次操作都需要操作一次数据库。 <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em>JDBC批处理</em></strong>，在本次实验，开启事务与关闭事务，耗时差距很微小（后面会增加测试，加大这个数值的差距）。但是能够看到开启事务以后，速度还是有提升。</p>
  
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><em>结论，设计到大量单条数据的插入，使用JDBC批处理和事务混合速度最快</em></strong> <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><em>实测使用批处理+事务混合插入1亿条数据耗时：174756毫秒</em></strong></p>
</blockquote>

<hr>

<hr>

<p><strong>提示：</strong></p>

<blockquote>
  <p>下列只是部分代码，<a href="git@github.com:taohaowei/testBigData.git">git@github.com:taohaowei/testBigData.git</a> <br>
  转载请标明出处：—–by <a href="http://blog.csdn.net/q6834850">陶浩伟</a></p>
</blockquote>

<hr>

<hr>

<hr>

<hr>



<h3 id="4更多彩蛋"><strong><em>4、更多彩蛋</em></strong></h3>

<blockquote>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em>JDBC批处理事务</em></strong>，开启和关闭事务，测评插入20次，一次50W数据，一共<strong>一千万数据</strong>耗时： <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
  
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、<strong>开启事务</strong>(数据太长不全贴了)</p>
  
  <blockquote>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><em>插入1000W数据共耗时：197654</em></strong></p>
  </blockquote>
</blockquote>

<p>&gt;</p>

<blockquote>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、<strong>关闭事务</strong>(数据太长不全贴了)</p>
  
  <blockquote>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><em>插入1000W数据共耗时：200540</em></strong></p>
  </blockquote>
  
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
  
  <p>还是没很大的差距~</p>
</blockquote>

<hr>

<blockquote>
  <p><strong><a href="http://www.cnblogs.com/tommy-huang/p/4540407.html">借用</a>：</strong></p>
  
  <p><img src="https://taohaowei.github.io/savePicture/blog/19/8.png" alt="这里写图片描述" title=""></p>
  
  <p>分别是： </p>

<pre><code>           不用批处理，不用事务；

           只用批处理，不用事务；

           只用事务，不用批处理；

           既用事务，也用批处理；（很明显，这个最快，所以建议在处理大批量的数据时，同时使用批处理和事务）
</code></pre>
</blockquote></div>